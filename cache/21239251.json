{"by":"pg","id":21239251,"parent":21231717,"text":"What this<p><pre><code>  (def typecheck ((var f) arg env s r m)\n    (mev (cons (list (list f (list &#x27;quote arg)) env)\n               (fu (s r m)\n                 (if (car r)\n                     (pass var arg env s (cdr r) m)\n                     (sigerr &#x27;mistype s r m)))\n               s)\n         r\n         m))\n</code></pre>\nsays is, first create a function call<p><pre><code>  (list f (list &#x27;quote arg))\n</code></pre>\nin which the function describing the type (e.g. int) is called on the argument that came in for that parameter. Its value will end up on the return value stack, r. So in the next step you look at the first thing on the return value stack<p><pre><code>  (car r)\n</code></pre>\nIf it&#x27;s true, you keep going as if the parameter had been a naked one, with no type restriction<p><pre><code>  (pass var arg env s (cdr r) m)\n</code></pre>\nand if it&#x27;s false, you signal an error<p><pre><code>  (sigerr &#x27;mistype s r m)</code></pre>","time":1570955826,"type":"comment","createdOn":"2021-12-13T23:45:39.850","ttl":600}