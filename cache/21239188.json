{"by":"pg","id":21239188,"kids":[21243051,21243292,21239666,21242739],"parent":21237636,"text":"One answer to this question (and an exciting idea in itself) is that the difference between conciseness and many of these apparently unrelated matters approaches zero. E.g. that all other things being equal, the debuggability of a language, and the pleasure one feels in using it, will be inversely proportional to the length of programs written in it.<p>I&#x27;m not sure how true that statement is, but my experience so far suggests that it is not only true a lot of the time, but that its truth is part of a more general pattern extending even to writing, engineering, architecture, and design.<p>As for the question of catching errors at compile time, it may be that there are multiple styles of programming, perhaps suited to different types of applications. But at least some programming is &quot;exploratory programming&quot; where initially it&#x27;s not defined whether code is correct because you don&#x27;t even know what you&#x27;re trying to do yet. You&#x27;re like an architect sketching possible building designs. Most programming I do seems to be of this type, and I find that what I want most of all is a flexible language in which I can sketch ideas fast. The constraints that make it possible to catch lots of errors at compile time (e.g. having to declare the type of everything) tend to get in the way when doing this.<p>Lisp turned out to be good for exploratory programming, and in Bel I&#x27;ve tried to stick close to Lisp&#x27;s roots in this respect. I wasn&#x27;t even tempted by schemes (no pun intended) for hygienic macros, for example. Better to own the fact that you&#x27;re generating code in its full, dangerous glory.<p>More generally, I&#x27;ve tried to stick close to the Lisp custom of doing everything with lists, at least initially, without thinking or even knowing what types of things you&#x27;re using lists to represent.","time":1570954564,"type":"comment","createdOn":"2021-12-13T23:45:40.973","ttl":600}